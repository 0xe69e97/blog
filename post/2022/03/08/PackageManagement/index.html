<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.25" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme='dark'] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background-color: var(--vp-c-bg);
      }
    </style>
    <script>
      const useChoice = localStorage.getItem('vuepress-color-scheme')
      const systemStatus =
        'matchMedia' in window
          ? window.matchMedia('(prefers-color-scheme: dark)').matches
          : false

      if (useChoice === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (useChoice === 'dark' || systemStatus) {
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><title>包管理工具 | 离殊的博客</title><meta name="description" content="离殊的博客">
    <link rel="preload" href="/assets/style-DX_uggt_.css" as="style"><link rel="stylesheet" href="/assets/style-DX_uggt_.css">
    <link rel="modulepreload" href="/assets/app-igEGucXV.js"><link rel="modulepreload" href="/assets/index.html-4WhGFOh_.js">
    <link rel="prefetch" href="/assets/index.html-Bq-IpbT_.js" as="script"><link rel="prefetch" href="/assets/index.html-Ctkgkotr.js" as="script"><link rel="prefetch" href="/assets/index.html-BvvSJzCk.js" as="script"><link rel="prefetch" href="/assets/index.html-COyCXRQ8.js" as="script"><link rel="prefetch" href="/assets/index.html-Dg4J3gQH.js" as="script"><link rel="prefetch" href="/assets/index.html-BDXRmSue.js" as="script"><link rel="prefetch" href="/assets/index.html-kK6qt4Vj.js" as="script"><link rel="prefetch" href="/assets/index.html-BnzNag6p.js" as="script"><link rel="prefetch" href="/assets/index.html-Cgxb9UVq.js" as="script"><link rel="prefetch" href="/assets/index.html-fC3HOxfC.js" as="script"><link rel="prefetch" href="/assets/index.html-BE3s2cNu.js" as="script"><link rel="prefetch" href="/assets/index.html-B_3FPNY8.js" as="script"><link rel="prefetch" href="/assets/index.html-BdW98VTy.js" as="script"><link rel="prefetch" href="/assets/index.html-DImDCflB.js" as="script"><link rel="prefetch" href="/assets/index.html-QPrbtHf5.js" as="script"><link rel="prefetch" href="/assets/index.html-jRQzdyvr.js" as="script"><link rel="prefetch" href="/assets/index.html-DfpEmwHX.js" as="script"><link rel="prefetch" href="/assets/index.html-C8JPwFOC.js" as="script"><link rel="prefetch" href="/assets/index.html-DWfP8_UO.js" as="script"><link rel="prefetch" href="/assets/index.html-CO_O86Zk.js" as="script"><link rel="prefetch" href="/assets/index.html-DcJiGjbp.js" as="script"><link rel="prefetch" href="/assets/index.html-mEfs6vOG.js" as="script"><link rel="prefetch" href="/assets/index.html-DYBOplpI.js" as="script"><link rel="prefetch" href="/assets/index.html-Zz-84VPm.js" as="script"><link rel="prefetch" href="/assets/index.html-BbtX7JTg.js" as="script"><link rel="prefetch" href="/assets/index.html-8JYUwZWm.js" as="script"><link rel="prefetch" href="/assets/index.html-CJT5Me-F.js" as="script"><link rel="prefetch" href="/assets/index.html-DPqq69PO.js" as="script"><link rel="prefetch" href="/assets/404.html-BkO9hCrg.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container no-sidebar external-link-icon" vp-container><!--[--><header class="vp-navbar" vp-navbar><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/"><!----><span class="vp-site-name" aria-hidden="true">离殊的博客</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/" aria-label="Home"><!--[--><!--[--><!--]--><!--]-->Home<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/posts/" aria-label="Posts"><!--[--><!--[--><!--]--><!--]-->Posts<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/tags/" aria-label="Tags"><!--[--><!--[--><!--]--><!--]-->Tags<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/links/" aria-label="Links"><!--[--><!--[--><!--]--><!--]-->Links<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="auto-link external-link" href="https://github.com/0xe69e97" aria-label="Github" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->Github<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button type="button" class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar" vp-sidebar><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/" aria-label="Home"><!--[--><!--[--><!--]--><!--]-->Home<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/posts/" aria-label="Posts"><!--[--><!--[--><!--]--><!--]-->Posts<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/tags/" aria-label="Tags"><!--[--><!--[--><!--]--><!--]-->Tags<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/links/" aria-label="Links"><!--[--><!--[--><!--]--><!--]-->Links<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="auto-link external-link" href="https://github.com/0xe69e97" aria-label="Github" rel="noopener noreferrer" target="_blank"><!--[--><!--[--><!--]--><!--]-->Github<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><!----><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div vp-content><!--[--><!--]--><div id="content"><p>本次分享不会包含使用方式，如感兴趣可以自行查看</p><h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><p>前端的包管理工具相信大家一定不会陌生，因为每天都需要跟他打交道，新项目或者刚拉下来的前端项目都需要去 <code>install</code> 依赖进行包的依赖安装，大家最熟悉的应该就是 <code>npm</code> 了，或者国内的 <code>npm</code> 镜像包 <code>cnpm</code> ，大家熟称为<code>淘宝镜像</code></p><p>但是现在，<code>npm</code> 已经是前端家喻户晓的存在了，为什么还会出现诸如 <code>cnpm</code> <code>Yarn</code> <code>pnpm</code> <code>Yarn2</code> 等等...今天就让我带大家一起一探究竟，为什么已经出现如此之久的 <code>npm</code> 还会有<strong>重复造轮子</strong>的包管理呢？</p><h2 id="包管理工具的功能" tabindex="-1"><a class="header-anchor" href="#包管理工具的功能"><span>包管理工具的功能</span></a></h2><ul><li>处理和编写元数据</li><li>批量安装或更新所有依赖项</li><li>添加、更新和删除依赖项</li><li>运行脚本</li><li>发布软件包</li><li>进行安全审查</li></ul><h2 id="简史" tabindex="-1"><a class="header-anchor" href="#简史"><span>简史</span></a></h2><p>第一个发布的软件包管理器是 <code>npm</code> ，早在 2010 年就已经存在了。它确立了如今包管理的核心，在前端包管理工具相当于是一种标准了。</p><p>如今 <code>npm</code> 已经存在 12 年了，为什么还有其他替代品？</p><ul><li>node_modules 不同的依赖解析算法，嵌套 VS 扁平化</li><li>不同的安全问题</li><li>不同的锁文件格式，有性能影响</li><li>在磁盘上存储包的不同方式，对磁盘空间有效率影响 <img src="https://cdn.jsdelivr.net/gh/0xe69e97/image-PicX@master/Blog/image.4qliey5xshi0.png" alt="image"></li><li>对多包（单一代码库）项目的不同支持</li><li>不同程度的可配置性和灵活性</li></ul><h2 id="主流包管理器" tabindex="-1"><a class="header-anchor" href="#主流包管理器"><span>主流包管理器</span></a></h2><ul><li><a href="https://docs.npmjs.com/getting-started" target="_blank" rel="noopener noreferrer">npm</a></li><li><a href="https://yarn.bootcss.com/" target="_blank" rel="noopener noreferrer">Yarn</a></li><li><a href="https://pnpm.io/zh/" target="_blank" rel="noopener noreferrer">pnpm</a></li><li><a href="https://yarnpkg.com/getting-started/migration" target="_blank" rel="noopener noreferrer">Yarn Berry</a> (还未发布)</li></ul><h2 id="npm" tabindex="-1"><a class="header-anchor" href="#npm"><span>npm</span></a></h2><p><img src="https://cdn.jsdelivr.net/gh/0xe69e97/image-PicX@master/images/image.24k4eb9g0kkg.webp" alt="image"></p><p>npm 是包管理器的祖先。许多人错误地认为 npm 是 “Node 包管理器” 的首字母缩写，但事实并非如此。尽管如此，它与 Node.js 运行时捆绑在一起。</p><p>在 npm 之前，项目依赖都是手动下载和管理的。</p><p>npm 引入了一些概念：</p><ul><li>package.json 文件</li><li>元数据字段（例如，devDependencies）</li><li>node_modules 中存储依赖项</li><li>自定义脚本</li><li>公共和私有包注册</li></ul><p>在 node_modules 中存储依赖项、自定义脚本、公共和私有包注册等概念都是 npm 引入的</p><h2 id="yarn-v1" tabindex="-1"><a class="header-anchor" href="#yarn-v1"><span>Yarn (v1)</span></a></h2><p><img src="https://cdn.jsdelivr.net/gh/0xe69e97/image-PicX@master/images/image.3aw5btn4io80.webp" alt="image"></p><p>Yarn 是 Facebook 宣布与谷歌和其他一些公司开发新的软件包管理器，主要解决 npm 当时存在的一致性、安全性和性能问题，他们命名为 Yarn</p><p>Yarn 的架构设计建立在 npm 许多概念和流程之上，Yarn 在最初的发布中对包管理器产生了重大影响。Yarn 在安装依赖的过程中采用了并行安装，这是 npm 当时的一大痛点</p><p>Yarn 还发明了自己的许多概念，例如：</p><ul><li>原生 <code>monorpo</code> 支持</li><li>缓存感知安装</li><li>离线缓存</li><li>锁文件</li></ul><p>目前 Yarn 的热度在包管理器的热度上也是数一数二了。</p><h3 id="特点" tabindex="-1"><a class="header-anchor" href="#特点"><span>特点</span></a></h3><ol><li>速度快</li></ol><ul><li><code>Yarn</code> 缓存了每个下载过的包，所以再次使用时无需重复下载</li><li>同时利用并行下载以最大化资源利用率，因此安装速度更快</li></ul><ol start="2"><li>安全</li></ol><ul><li>在执行代码之前，<code>Yarn</code> 会通过算法校验每个安装包的完整性</li></ul><ol start="3"><li>可靠</li></ol><ul><li>使用详细、简洁的锁文件格式和明确的安装算法，Yarn 能够保证在不同系统上无差异的工作</li></ul><h3 id="创新性" tabindex="-1"><a class="header-anchor" href="#创新性"><span>创新性</span></a></h3><ol><li>离线模式</li></ol><ul><li>如果你以前安装过某个包，再次安装时可以在没有任何互联网连接的情况下进行。</li></ul><ol start="2"><li>确定性</li></ol><ul><li>不管安装顺序如何，相同的依赖关系将在每台机器上以相同的方式安装</li></ul><ol start="3"><li>网络性能</li></ol><ul><li>Yarn 有效地对请求进行排队处理，避免发起的请求如瀑布般倾泻，以便最大限度地利用网络资源</li></ul><ol start="4"><li>相同的软件包</li></ol><ul><li>从 npm 安装软件包并保持相同的包管理流程</li></ul><ol start="5"><li>网络弹性</li></ol><ul><li>重试机制确保单个请求失败并不会导致整个安装失败</li></ul><ol start="6"><li>扁平模式</li></ol><ul><li>将依赖包的不同版本归结为单个版本，以避免创建多个副本</li></ul><h2 id="pnpm" tabindex="-1"><a class="header-anchor" href="#pnpm"><span>pnpm</span></a></h2><p><img src="https://cdn.jsdelivr.net/gh/0xe69e97/image-PicX@master/images/image.4vjc5g7p44q0.webp" alt="image"></p><p>pnpm 是一个比较新颖的包管理工具。它和 Yarn 一样，是为了解决某些 npm 痛点的。可以说是 npm 的替换，如果你现在的项目是 npm 项目，那么可以直接使用 Pnpm</p><p>Pnpm 的出现是为了解决 Yarn 的问题，因为 Yarn 不解决例如磁盘占用的问题以及内部的发展不公开等原因，所以就自己去开发了一个，目前在使用体验上要比 Yarn 好一些而且解决了一些 Yarn 目前存在的问题以及痛点，感兴趣的同学可以看看原文。<a href="https://www.kochan.io/nodejs/why-should-we-use-pnpm.html" target="_blank" rel="noopener noreferrer">Why should we use pnpm?</a></p><p>虽然 Yarn 的速度优于 npm，但是它使用了相同的依赖解析方法</p><p>现在的前端项目越来越庞大，复杂。很多时候有成百上千的依赖包，每次安装都需要一定的时间，并且大量浪费磁盘空间。</p><p>pnpm 引入了一种替代的依赖解析策略：内容寻址存储。</p><p>这个方式导致你的 node_modules 文件夹里面的依赖包都将存储在 <code>~/.pnpm-store/</code> 下。每个依赖包的版本在该文件夹中只存储一次，构成唯一来源，这样的话将会节省相当多的磁盘空间。</p><p>这是通过 <code>node_modules</code> 层实现的，使用符号链接创建一个嵌套的依赖关系结构，其中文件夹中的每个包都是到存储的硬链接。</p><p><img src="https://cdn.jsdelivr.net/gh/0xe69e97/image-PicX@master/Blog/image.6ifyfzspesk0.webp" alt="image"></p><p>这是为什么 <code>pnpm</code> 会在快速和磁盘效率上有大幅提升的原因。</p><h3 id="它是如何工作的" tabindex="-1"><a class="header-anchor" href="#它是如何工作的"><span>它是如何工作的？</span></a></h3><p>官网介绍</p><blockquote><ol><li>如果依赖于依赖项的不同版本，则只有不同的文件才会添加到存储区。例如，如果它有100个文件，而一个新版本只在其中一个文件中有更改，pnpm update 将只向存储中添加一个新文件，而不是为了这个单一的更改而克隆整个依赖。</li><li>所有的文件都保存在磁盘上的一个地方。安装包时，它们的文件将从该位置硬链接，不消耗额外的磁盘空间。这允许您在项目之间共享相同版本的依赖项。</li></ol></blockquote><p>由于这种依赖关系的链接，它也比它的替代品快 2 倍。通过使用这项技术和一些真正高性能的缓存解决方案，您可以在眨眼之间安装包</p><h2 id="yarn-berry" tabindex="-1"><a class="header-anchor" href="#yarn-berry"><span>Yarn Berry</span></a></h2><p><code>Yarn 2</code> 也称为 <code>Yarn Berry</code>，2020 年 1 月发布，据称是对 <code>Yarn</code> 的重大升级。它本质上是一个新的包管理器，新的代码基础和新原则，所以称为 <code>Yarn Berry</code>。</p><p><strong>Yarn Berry 太激进了，所以我们只简单讨论一些吧，感兴趣的同学可以自己去看看，目前最新版本已经到 3 了</strong></p><p><code>Yarn Berry</code> 的主要创新是 PnP（Plug&#39;n&#39;Play，即插即用 ），这种方法是修复 node_modules 的策略而产生的。相当于抛弃了 <code>node_modules</code></p><blockquote><p>原生 node 的查找依赖方式是向上级目录层层递归遍历 node_modules 文件夹，虽然，现有的包管理版本都已经做到了依赖提升，让依赖项尽量扁平化，但当碰到包依赖版本不匹配的时候，仍然会存在嵌套目录。 而 PnP，它记录了依赖的准群硬盘位置，可以在查找依赖时减少硬盘读写，同时，可以做到所有依赖项完全扁平化。</p></blockquote><p>本质上，就是将你的依赖项通过下载并解析成 zip 的形式放到你的 <code>.yarn/cache</code> 目录下，通过提交源码将当前所有的 zip 文件上传，然后当其他团队成员在 <code>down</code> 代码的时候直接可以运行项目而不需要特意去安装。</p><h4 id="安装-yarn-berry" tabindex="-1"><a class="header-anchor" href="#安装-yarn-berry"><span>安装 Yarn Berry</span></a></h4><p>因为 <code>Yarn berry</code> 比较特殊，需要通过当前目录进行安装，而不是作为一个全局管理，类似于只安装当前文件内</p><h5 id="升级-yarn-2-或以上版本" tabindex="-1"><a class="header-anchor" href="#升级-yarn-2-或以上版本"><span>升级 Yarn 2 或以上版本</span></a></h5><div class="language-bash line-numbers-mode" data-highlighter="prismjs" data-ext="sh"><pre><code class="language-bash"><span class="line">// <span class="token function">yarn</span> 版本在 <span class="token number">1.22</span>+</span>
<span class="line"><span class="token function">yarn</span> <span class="token builtin class-name">set</span> version berry</span>
<span class="line"></span>
<span class="line">// 安装 react</span>
<span class="line"><span class="token function">yarn</span> <span class="token function">add</span> react</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>依赖结构如下:</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">.</span>
<span class="line">├── .pnp.cjs</span>
<span class="line">├── .yarn</span>
<span class="line">│   ├── .DS_Store</span>
<span class="line">│   ├── cache</span>
<span class="line">│   │   ├── .gitignore</span>
<span class="line">│   │   ├── js-tokens-npm-4.0.0-0ac852e9e2-8a95213a5a.zip</span>
<span class="line">│   │   ├── loose-envify-npm-1.4.0-6307b72ccf-6517e24e0c.zip</span>
<span class="line">│   │   ├── object-assign-npm-4.1.1-1004ad6dec-fcc6e4ea8c.zip</span>
<span class="line">│   │   └── react-npm-17.0.2-99ba37d931-b254cc17ce.zip</span>
<span class="line">│   ├── install-state.gz</span>
<span class="line">│   └── releases</span>
<span class="line">│       └── yarn-berry.js</span>
<span class="line">├── .yarnrc.yml</span>
<span class="line">├── package.json</span>
<span class="line">└── yarn.lock</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>依赖大小</p><p>使用 <code>create-react-app </code> 默认依赖进行对比</p><h5 id="npm-1" tabindex="-1"><a class="header-anchor" href="#npm-1"><span>Npm</span></a></h5><p><img src="https://cdn.jsdelivr.net/gh/0xe69e97/image-PicX@master/images/image.27w8xpz23ha8.webp" alt="image"></p><h5 id="yarn-berry-1" tabindex="-1"><a class="header-anchor" href="#yarn-berry-1"><span>Yarn Berry</span></a></h5><p><img src="https://cdn.jsdelivr.net/gh/0xe69e97/image-PicX@master/images/image.5b6nejh5nc40.webp" alt="image"></p><h5 id="pnpm-1" tabindex="-1"><a class="header-anchor" href="#pnpm-1"><span>Pnpm</span></a></h5><p><img src="https://cdn.jsdelivr.net/gh/0xe69e97/image-PicX@master/images/image.ytgo176aci8.webp" alt="image"></p><p>可以发现依赖包的大小为 <code>npm &gt; Yarn Berry &gt; Pnpm</code></p><p><code>Yarn Berry</code>主要是将依赖下载成 zip 形式存储，但是 Node 无法解析 zip 格式的依赖包，所以使用了 .pnp.js 来维护映射关系，我们将 <code>Yarn Berry</code> 生成的所有依赖可以直接上传到 git 上，其他成员拉下代码后，即可直接运行，实现 Zero Install</p><h2 id="对比" tabindex="-1"><a class="header-anchor" href="#对比"><span>对比</span></a></h2><ul><li><ol><li>玄学</li></ol></li><li><ol start="2"><li>依赖管理</li></ol></li><li><ol start="3"><li>安全</li></ol></li><li><ol start="4"><li>速度</li></ol></li></ul><h3 id="_1-玄学" tabindex="-1"><a class="header-anchor" href="#_1-玄学"><span>1. 玄学</span></a></h3><p>不知道大家在使用过 <code>npm</code> 或者 <code>Yarn</code> 的时候有没有一种感受，就是在输入 <code>Yarn install</code> 或者 <code>Yarn</code> 的时候，要比 <code>npm</code> 更加舒适？</p><p><img src="https://cdn.jsdelivr.net/gh/0xe69e97/image-PicX@master/images/image.49b0snp4o9o0.webp" alt="image"></p><p>由于 <code>n p m</code> 三个字母都在键盘的右侧区域，所以正常打字的话可能需要一只手去输入。所以这就造成了 <code>npm</code> 的复杂度是 O(n)，而 <code>Yarn</code> 的复杂度为 O(log n)，虽然多了一个字母，但是分别在左右手区域各两个，所以在输入时更加顺畅，你自己在输入 <code>np</code> 的时候，你就已经可以把 <code>yarn</code> 输入完成了。</p><p>所以 pnpm 在输入上更略逊一筹，比 npm 还要难以输入...</p><h3 id="_2-依赖管理" tabindex="-1"><a class="header-anchor" href="#_2-依赖管理"><span>2. 依赖管理</span></a></h3><h4 id="依赖结构" tabindex="-1"><a class="header-anchor" href="#依赖结构"><span>依赖结构</span></a></h4><p>安装依赖时的原理：</p><ol><li>将依赖包的版本区间解析为某个具体的版本号</li><li>下载对应版本依赖的 tar 包到本地离线镜像</li><li>将依赖从离线镜像解压到本地缓存</li><li>将依赖从缓存拷贝到当前目录的 node_modules 目录</li></ol><h5 id="npm-2" tabindex="-1"><a class="header-anchor" href="#npm-2"><span>npm</span></a></h5><ul><li>在 <code>npm v1</code> <code>npm v2</code> 版本中，依赖包的管理是树结构嵌套组成的</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">node_modules</span>
<span class="line">└─ foo</span>
<span class="line">   ├─ index.js</span>
<span class="line">   ├─ package.json</span>
<span class="line">   └─ node_modules</span>
<span class="line">      └─ bar</span>
<span class="line">         ├─ index.js</span>
<span class="line">         └─ package.json</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果出现大量重复的包，将重复安装多个，会导致 <code>node_modules</code> 非常巨大，形成嵌套地狱。与我们之前在 JS 内写<code>回调地狱</code>类似</p><ul><li><code>v3</code> 版本之后使用扁平化管理</li></ul><h5 id="yarn" tabindex="-1"><a class="header-anchor" href="#yarn"><span>Yarn</span></a></h5><ul><li>默认使用扁平化依赖管理</li></ul><p>安装一个 <code>React</code>，发现在 node_modules 目录内有其他包文件</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">.</span>
<span class="line">└── node_modules</span>
<span class="line">    ├── js-tokens</span>
<span class="line">    ├── loose-envify</span>
<span class="line">    ├── object-assign</span>
<span class="line">    └── react</span>
<span class="line">        ├── cjs</span>
<span class="line">        ├── node_modules</span>
<span class="line">        └── umd</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将 <code>React</code> 需要的依赖都给打平到 <code>node_modules</code> 目录内，这个方案解决了嵌套地狱的问题，根据 <code>node require</code> 机制会不停的往上级 <code>node_modules</code> 去寻找，找到了就不会安装，解决了大量包重复安装的问题。</p><p>虽然解决了，但是扁平化的处理方式还存在一些问题。</p><ol><li>模块可以访问他们<strong>并不依赖的包</strong></li><li>平展依赖树的算法非常复杂</li><li>一些软件包在一个项目中被复制 node_modules 模块/文件夹</li></ol><h5 id="pnpm-2" tabindex="-1"><a class="header-anchor" href="#pnpm-2"><span>pnpm</span></a></h5><p>pnpm 会创建&quot;奇怪&quot;的 node_modules 结构</p><p><strong>pnpm 解决的不是平铺目录所带来的问题，而是解决 <code>npm v3</code> 版本之前的树结构的依赖问题</strong></p><p>我们先创建两个目录进行比较，先建立一个 npm 的包管理项目，然后在建立一个 pnpm 包管理项目</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">npm init</span>
<span class="line">npm install react</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>然后看一下 <code>npm/node_modules</code> 里面的内容</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">.</span>
<span class="line">├── js-tokens</span>
<span class="line">├── loose-envify</span>
<span class="line">├── object-assign</span>
<span class="line">└── react</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上所述，建立了平铺的结构，其他我们不认识的依赖都是 React 本身的依赖，被打平在这儿</p><p>我们在继续在 pnpm 里进行操作</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">pnpm init</span>
<span class="line">pnpm install</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">├── .pnpm</span>
<span class="line">└── react -&gt; .pnpm/react@17.0.2/node_modules/react</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>我们发现，除了一个我们不认识的 <code>.pnpm</code> 文件夹，只有一个 <code>react</code> 目录。 那么所有的次级依赖去哪里了呢？就在 <code>.pnpm</code> 的文件夹里面，我们打开后可以看到所有的依赖（包括依赖的依赖）都在 <code>.pnpm</code> 文件夹内，所以 <code>react</code> 是唯一一个你的应用必须拥有访问权限的包。</p><p>外面的 可以看到 <code>react</code> 是一个符号链接指向了它的真实位置</p><p><code>react</code> 包的真实位置在 <code>/node_modules/.pnpm/react@17.0.2/node_modules/react</code></p><p>所有你安装的依赖都存在 <code>.pnpm/&lt;name&gt;@&lt;version&gt;/node_modules/&lt;name&gt;</code> ，官方称它为虚拟存储目录</p><p>看一下 <code>react</code> 真实的位置内容</p><p><code>.pnpm/react@17.0.2/node_modules/react/node_modules</code></p><p>里面没有 <code>node_modules</code> 目录，那么 <code>react</code> 的依赖去哪里了？</p><p>其实 <code>react</code> 的所有依赖都被软链到了 <code>node_modules/.pnpm/</code> 中的对应目录了，这样将所有依赖放置同一级别可以避免循环的软链</p><h5 id="对比一下-npm-yarn-pnpm-工作机制" tabindex="-1"><a class="header-anchor" href="#对比一下-npm-yarn-pnpm-工作机制"><span>对比一下 Npm / Yarn / Pnpm 工作机制</span></a></h5><p>画了一张略微有点乱的图</p><p><img src="https://raw.githubusercontent.com/0xe69e97/image-PicX/master/images/image.52rdpqqb8mg0.webp" alt="image"></p><h3 id="_3-安全" tabindex="-1"><a class="header-anchor" href="#_3-安全"><span>3. 安全</span></a></h3><p><code>npm / yarn</code> 的扁平依赖结构，有一个非常严重的问题就是可以<strong>非法访问未声明的包</strong></p><p>举个🌰</p><p>我们使用 <code>Antd</code> 包，可以直接引用 <code>Antd</code> 内部实现包，例如 <code>rc-table</code></p><p><img src="https://cdn.jsdelivr.net/gh/0xe69e97/image-PicX@master/images/image.4n7m2l9vq700.webp" alt="image"></p><p><img src="https://cdn.jsdelivr.net/gh/0xe69e97/image-PicX@master/images/image.570othzirg00.webp" alt="image"></p><p>那么 pnpm 像上文介绍一样，将依赖通过 link 的形式避免了<strong>非法访问依赖</strong>的问题，如果没在 <code>package.json</code> 声明的话，是无法访问的。</p><p>在举个🌰</p><p>我们在 <code>yarn</code> 的包管理工具下，引入一个 <code>react</code> 使用的包 <code>object-assign</code>。然后在 index.js 下输入以下代码</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">const objectAssign = require(&#39;object-assign&#39;)</span>
<span class="line">console.log(objectAssign)</span>
<span class="line"></span>
<span class="line">[Function: assign]</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>继续在 <code>pnpm</code> 下使用上述代码以及对应流程</p><p>在控制台输出 <code>Cannot find module &#39;object-assign&#39;</code></p><p>如果你要硬刚写路径，也不是不可以访问。。。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">const objectAssign = require(&#39;./node_modules/.pnpm/object-assign@4.1.1/node_modules/object-assign/index.js&#39;)</span>
<span class="line">console.log(objectAssign)</span>
<span class="line"></span>
<span class="line">[Function: assign]</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="缓存" tabindex="-1"><a class="header-anchor" href="#缓存"><span>缓存</span></a></h3><p>npm / Yarn：把 tgz 解包成 tar 作为全局缓存，再次安装依赖时解压到 node_modules。</p><p>Yarn Berry：把所有的文件下载到当前项目中，压缩成 zip 的形式存储</p><p>pnpm：把 tgz 解压为文件，以 hash 方式全局缓存， 同个包的不同版本的同个文件也能共享，再次安装时直接硬链接过去。</p><h3 id="_4-速度" tabindex="-1"><a class="header-anchor" href="#_4-速度"><span>4. 速度</span></a></h3><h4 id="npm-35s" tabindex="-1"><a class="header-anchor" href="#npm-35s"><span>npm 35s</span></a></h4><p><img src="https://cdn.jsdelivr.net/gh/0xe69e97/image-PicX@master/Blog/image.70rkf1d6qw00.webp" alt="image"></p><h4 id="yarn-4s" tabindex="-1"><a class="header-anchor" href="#yarn-4s"><span>Yarn 4s</span></a></h4><p><img src="https://cdn.jsdelivr.net/gh/0xe69e97/image-PicX@master/Blog/image.5pbpivdx24c0.webp" alt="image"></p><h4 id="pnpm-2s" tabindex="-1"><a class="header-anchor" href="#pnpm-2s"><span>pnpm 2s</span></a></h4><p><img src="https://cdn.jsdelivr.net/gh/0xe69e97/image-PicX@master/Blog/image.cvvonk0kx9k.webp" alt="image"></p><h4 id="yarn-berry-14s" tabindex="-1"><a class="header-anchor" href="#yarn-berry-14s"><span>Yarn Berry 14s</span></a></h4><p><img src="https://cdn.jsdelivr.net/gh/0xe69e97/image-PicX@master/images/image.3rn8n3a5bd00.webp" alt="image"></p><h3 id="测试下磁盘效率" tabindex="-1"><a class="header-anchor" href="#测试下磁盘效率"><span>测试下磁盘效率</span></a></h3><p>用了一个多包的仓库测试的～</p><p>左侧是 pnpm ，右侧是 yarn / npm</p><p><img src="https://cdn.jsdelivr.net/gh/0xe69e97/image-PicX@master/Blog/image.4lbo850usq00.webp" alt="image"></p><h3 id="pnpm-官网特性对比表" tabindex="-1"><a class="header-anchor" href="#pnpm-官网特性对比表"><span>pnpm 官网特性对比表</span></a></h3><table><thead><tr><th style="text-align:left;">功能</th><th>pnpm</th><th>Yarn</th><th>npm</th></tr></thead><tbody><tr><td style="text-align:left;">工作空间支持（monorepo）</td><td>✔️</td><td>✔️</td><td>✔️</td></tr><tr><td style="text-align:left;">隔离的 <code>node_modules</code></td><td>✔️ - 默认</td><td>✔️</td><td>✔️</td></tr><tr><td style="text-align:left;">提升的 <code>node_modules</code></td><td>✔️</td><td>✔️</td><td>✔️ - 默认</td></tr><tr><td style="text-align:left;">Plug&#39;n&#39;Play</td><td>✔️</td><td>✔️ - 默认</td><td>✔️</td></tr><tr><td style="text-align:left;">零安装</td><td>❌</td><td>✔️</td><td>❌</td></tr><tr><td style="text-align:left;">修补依赖项</td><td>❌</td><td>✔️</td><td>❌</td></tr><tr><td style="text-align:left;">管理 Node.js 版本</td><td>✔️</td><td>❌</td><td>❌</td></tr><tr><td style="text-align:left;">有锁文件</td><td>✔️ - <code>pnpm-lock.yaml</code></td><td>✔️ - <code>Yarn.lock</code></td><td>✔️ - <code>package-lock.json</code></td></tr><tr><td style="text-align:left;">支持覆盖</td><td>✔️</td><td>✔️ - 通过 resolutions</td><td>✔️</td></tr><tr><td style="text-align:left;">内容可寻址存储</td><td>✔️</td><td>❌</td><td>❌</td></tr><tr><td style="text-align:left;">动态包执行</td><td>✔️ - 通过 pnpm dlx</td><td>✔️ - 通过 Yarn dlx</td><td>✔️ - 通过 npx</td></tr></tbody></table><h2 id="开源库使用的包管理工具" tabindex="-1"><a class="header-anchor" href="#开源库使用的包管理工具"><span>开源库使用的包管理工具</span></a></h2><p>举几个开源库的包管理使用情况</p><table><thead><tr><th style="text-align:left;">npm</th><th>Yarn</th><th>Yarn Berry</th><th>pnpm</th></tr></thead><tbody><tr><td style="text-align:left;">svelte</td><td>React</td><td>Jest</td><td>Vue 3</td></tr><tr><td style="text-align:left;">Express</td><td>Next.js</td><td>Babel</td><td>Browserlist</td></tr><tr><td style="text-align:left;">Apollp Server</td><td>Webpack-cli</td><td>Redux Toolkit</td><td>SvelteKit</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/0xe69e97/image-PicX/master/images/image.52rdpqqb8mg0.webp" alt="image"></p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>个人在 Yarn 刚出没多久的时候就已经在使用了，算是 Yarn 的常年老用户粉了。从 0.x 的版本开始，因为之前用 npm 不是安装依赖太慢，就是安装中途出错，或者设置淘宝镜像去使用。所以我干脆就换成 Yarn 了。一直使用至今的 1.22.x 版本</p><p>所以我在看到有人用 npm 的时候就忍不住一直在推荐 Yarn 作为包管理工具，每次接手或者新开发的项目也是。。。</p><p>在对 npm / Yarn / Pnpm / Yarn Berry 做了简单的对比之后相信大家自己心里会有一定的判断</p><p>希望以后包管理工具可以有一个标准规范吧，这样的话我们也不用去纠结使用哪些工具，对比他们的内部实现以及对业务上的支持等</p><h3 id="参考链接" tabindex="-1"><a class="header-anchor" href="#参考链接"><span>参考链接</span></a></h3><ul><li><a href="https://pnpm.io/zh/" target="_blank" rel="noopener noreferrer">PNPm</a></li><li><a href="https://blog.logrocket.com/javascript-package-managers-compared/" target="_blank" rel="noopener noreferrer">JavaScript package managers compared: npm, Yarn, or pnpm?</a></li><li><a href="https://loveky.github.io/2019/02/11/yarn-pnp/" target="_blank" rel="noopener noreferrer">Yarn 的 Plug&#39;n&#39;Play 特性</a></li><li><a href="https://www.kochan.io/nodejs/why-should-we-use-pnpm.html" target="_blank" rel="noopener noreferrer">Why should we use pnpm?</a></li><li><a href="https://javascript.plainenglish.io/npm-yarn-pnpm-which-node-js-package-manager-should-you-use-a2a1378694f7" target="_blank" rel="noopener noreferrer">NPM vs Yarn vs PNPM: Which Node.js Package Manager Should You Use?</a></li></ul></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">最近更新: </span><time class="meta-item-info" datetime="2025-10-11T09:00:34.000Z" data-allow-mismatch>2025/10/11 17:00</time></div><!----></div></footer><!----><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/assets/app-igEGucXV.js" defer></script>
  </body>
</html>
